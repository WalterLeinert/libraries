// Nodejs imports
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import * as util from 'util';


// -------------------------- logging -------------------------------
import { Logger, levels, configure, getLogger } from 'log4js';
import { XLog, using } from 'enter-exit-logger';
// -------------------------- logging -------------------------------

import { IGenerator } from './generator.interface';
import { TableInfo } from './tableInfo';
import { ColumnInfo, DataType } from './columnInfo';
import { IConfigInfo } from './configInfo';

/**
 * 
 */
export abstract class GeneratorBase implements IGenerator {
   static logger = getLogger('GeneratorBase');

    constructor(protected outputDir: string, protected configInfo: IConfigInfo) {
        using(new XLog(GeneratorBase.logger, levels.INFO, 'ctor', 'outputDir = %s', outputDir), (log) => {
            this.outputDir = path.normalize(outputDir);
            fs.stat(outputDir, (err, stats) => {
                if (!stats) {
                    fs.mkdir(outputDir, (err) => {
                        throw err;
                    });
                } else if (!stats.isDirectory()) {
                    throw new Error('No directory: ' + outputDir);
                }
            });
        });
    }

    public abstract generateFiles(tableInfos: TableInfo[]);
    public abstract generateFile(fileName: string, tableInfos: TableInfo[]);

    protected dumpHeader(fd: number) {
        GeneratorBase.writeLineSync(fd, '//');
        GeneratorBase.writeLineSync(fd, '// DO-NOT-EDIT');
        GeneratorBase.writeLineSync(fd, '//');
        GeneratorBase.writeLineSync(fd, util.format('// Model generated by %s', process.argv[1]));
        GeneratorBase.writeLineSync(fd, util.format('// Date: ', new Date().toISOString()));
        GeneratorBase.writeLineSync(fd, util.format('// Connection: host = %s, database = %s',
            this.configInfo.host, this.configInfo.database));
        GeneratorBase.writeLineSync(fd, '//');

        GeneratorBase.writeLineSync(fd);
    }

    static capitalizeFirstLetter(text: string) {
        return text.charAt(0).toUpperCase() + text.slice(1);
    }

    
    protected static writeCommentline(fd: number) {
        GeneratorBase.writeLineSync(fd, '//');
    }


    static writeLineSync(fd: number, text: string = '') {
        fs.writeSync(fd, text + os.EOL);
    }

    static formatDefaultValue(colInfo: ColumnInfo): string {
        let rval = '';

        if (colInfo.default) {
            let val = '';

            switch (colInfo.type) {
                case DataType.Number:
                    val = colInfo.default;
                    break;
                case DataType.String:
                    val = '"' + colInfo.default + '"';
                    break;
                case DataType.Date:
                    val = 'new Date("' + colInfo.default + '")';
                    break;
                default:
                    throw new Error(util.format('unsupported data type: %s', DataType[<number>colInfo.type]));
            }

            rval = ' = ' + val + ';';
        }
        return rval;
    }

    static mapDataType(type: DataType): string {
        switch (type) {
            case DataType.Number:
                return 'number'
            case DataType.String:
                return 'string';
            case DataType.Date:
                return 'Date';
            default:
                throw new Error(util.format('unsupported data type: %s', DataType[<number>type]));
        }
    }

    static quote(text: string): string {
        return '\'' + text + '\'';
    }

    
    static getClassName(info: TableInfo): string {
        return GeneratorBase.capitalizeFirstLetter(info.name);
    }

    static getInterfaceName(info: TableInfo): string {
        return 'I' + this.getClassName(info);
    }

    static getPrimaryKeyName(info: TableInfo): string {
        let pk = info.columns.filter(col => col.isPrimaryKey);
        if (!pk || pk.length <= 0) {
            return 'no-pk-column';
        }
        return pk[0].name;
    }

}